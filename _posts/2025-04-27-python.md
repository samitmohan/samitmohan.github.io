---
layout: post
title:  "how is python written"
date:   2025-04-27 14:06:04 +0530
categories: tech
tokens: "~4.2k"
---

In order to appreciate C, one must learn how C was written (assembly) to be grateful for all the cool things in C. Similarly, to appreciate Python we must understand how it's written (in C).

Python has many implementations (PyPy, JPython, etc.), but the original and most popular is [CPython](https://github.com/python/cpython).

---

## Getting Started with CPython Source Code

To download a copy of the CPython source code, you can use git to pull the latest version locally:

```bash
$ git clone https://github.com/python/cpython
$ cd cpython
$ git checkout v3.8.0b4  # or whatever version you prefer
```

Inside the newly downloaded `cpython` directory, you'll find the following structure:

```text
cpython/
│
├── Doc      ← Source for the documentation
├── Grammar  ← The computer-readable language definition
├── Include  ← The C header files
├── Lib      ← Standard library modules written in Python
├── Mac      ← macOS support files
├── Misc     ← Miscellaneous files
├── Modules  ← Standard Library Modules written in C
├── Objects  ← Core types and the object model
├── Parser   ← The Python parser source code
├── PC       ← Windows build support files
├── PCbuild  ← Windows build support files for older Windows versions
├── Programs ← Source code for the python executable and other binaries
├── Python   ← The CPython interpreter source code
└── Tools    ← Standalone tools useful for building or extending Python
```

It might seem daunting at first, but you really don't have to know how everything works + the more you explore, the more you'll appreciate Python & all the fun parts I could find are in this blog.

After forking and cloning the source code of Python, I broke down exploration into these sub-tasks:

- Finding the entry point (the main function) of Python
- Locating where specific functions are implemented
- Editing those functions
- Remaking grammar files/source files and running the modified Python

---

## Table of Contents

1. [The Walrus Operator](#the-walrus-operator)
2. [String Optimization](#string-optimization)
3. [Chained Comparison Operators](#chained-comparison-operators)
4. [Integer Optimization](#integer-optimization)
5. [How Python's id() Works](#how-pythons-id-works)
6. [Adding a New Statement to Python](#adding-a-new-statement-to-python)
7. [Function Overloading in Python](#function-overloading-in-python)
8. [Parser and Tokenization](#parser-and-tokenization)
9. [Visualizing Abstract Syntax Trees](#visualizing-abstract-syntax-trees)
10. [Pointers in Python](#pointers-in-python)
11. [The Print Function Internals](#the-print-function-internals)
12. [Python is slow as hell](#python-is-slow-as-hell)
13. [Python Execution Process](#python-execution-process)

---

## The Walrus Operator

Python 3.8 introduced Assignment Expressions with the Walrus Operator (`:=`). This expression both assigns and returns in the same expression, helping write more concise code.

Consider building a shell in Python that takes commands from the prompt, executes them, and renders the output until receiving an exit command:

**Without walrus:**

```python
command = input("$ ")
while command != "exit":
    os.system(command)
    command = input("$ ")
```

**With walrus:**

```python
while (command := input("$ ")) != "exit":
    os.system(command)
```

### What's weird about the Walrus operator?

Since the Walrus operator functions similarly to an assignment operator `=`, you might expect the following to work, but it produces a `SyntaxError`:

```python
>>> a := 10
  File "<stdin>", line 1
    a := 10
      ^
SyntaxError: invalid syntax
```

However, wrapping it in parentheses works:

```python
>>> (a := 10)
10
```

This behavior is documented in [wtf-python](https://github.com/satwikkansal/wtfpython). The explanation: Python disallows non-parenthesized Assignment Expressions but allows non-parenthesized assignment statements.

### Modifying Python's Grammar

We can modify Python's grammar to allow using the walrus operator without parentheses:

```python
# Add walrus operator here so we don't need () every time
expr_stmt: testlist_star_expr (annassign | augassign (yield_expr|testlist) |
                   [('=' (yield_expr|testlist_star_expr))+ [TYPE_COMMENT]] |
                   [(':=' (yield_expr|testlist_star_expr))+ [TYPE_COMMENT]]
                   )
```

The grammar file isn't directly used by the Python compiler. Instead, a parser table created by a tool called `pgen` is used. After changing the grammar file, we must regenerate the parser table and recompile Python.

After making these changes and running `make regen-pgen` and `make`, we can use the walrus operator without parentheses:

```python
>>> a := 10
>>> a
10
```

---

## String Optimization

Python optimizes string usage through a technique called **String Interning**:

```python
>>> a = 'samit'
>>> b = 'samit'
>>> a == b
True
>>> id(a)
4337581920  # memory location
>>> id(b)
4337581920  # same memory location
```

Both variables point to the same memory location. Python identified that we've already used the same string before and redirected `b`'s location to that address.

### String Interning

String Interning is a compiler/interpreter optimization that makes string processing tasks more efficient by caching strings. Instead of creating a new copy of a string every time, this method keeps just one copy of each distinct immutable string value and uses pointer references.

In Python, we can check if two objects refer to the same in-memory object using the `is` operator:

```python
>>> 'python' is 'python'
True
```

### How does it work?

The implementation can be found in the CPython source code:

```c
void PyUnicode_InternInPlace(PyObject **p)
{
    PyObject *s = *p;
    PyObject *t;
    // Check if already cached, return that
    if (PyUnicode_CHECK_INTERNED(s))
        return;
    if (interned == NULL) {
        interned = PyDict_New();  // create global mapping like a cache
        if (interned == NULL) {
            PyErr_Clear();
            return;
        }
    }
    // STRING INTERNING KEY -> we aren't really storing strings but rather pointers
    t = PyDict_SetDefault(interned, s, s);
    if (t == NULL) {
        PyErr_Clear();
        return;
    }

    if (t != s) {
        Py_INCREF(t);  // increases reference (more objects pointing to it)
        Py_SETREF(*p, t);  // sets *p = t so new p string points to instance of t
        return;
    }
    Py_REFCNT(s) -= 2;
    _PyUnicode_STATE(s).interned = SSTATE_INTERNED_MORTAL;
}
```

If we add a print statement, we can see the interning at work:

```text
>>> a = 'samit'
Already interned: __doc__
Already interned: __annotations__
Already interned: top
Interning: <module>
Interning: samit
Already interned: stderr
Already interned: flush
Already interned: flush
Already interned: stdout

>>> b = 'samit'
Already interned: samit  # already interned
```

---

## Chained Comparison Operators

Python supports chaining comparison operators, which means expressions like `a < b < c` are evaluated as `(a < b) and (b < c)`, making code more intuitive.

```python
>>> -3 < -2 < -1
True
>>> 3 > 2 == 1
False
```

In C language, the same expressions give opposite results:

```c
#include <stdio.h>

int main(int argc, char *argv[]) {
    printf("%d\n", -3 < -2 < -1);
    printf("%d\n", 3 > 2 == 1);
    return 0;
}

// Output:
// 0  // false
// 1  // true
```

This is because C evaluates `-3 < -2 < -1` as `((-3 < -2) < -1)` due to operator precedence.

### How Python implements comparison chaining

We can see the Python implementation using the `dis` module:

```python
dis.dis("1 < 2 < 3")
  0           RESUME                   0

  1           LOAD_CONST               0 (1)
              LOAD_CONST               1 (2)
              SWAP                     2
              COPY                     2
              COMPARE_OP               2 (<)
              COPY                     1
              TO_BOOL
              POP_JUMP_IF_FALSE        5 (to L1)
              POP_TOP
              LOAD_CONST               2 (3)
              COMPARE_OP               2 (<)
              RETURN_VALUE
      L1:     SWAP                     2
              POP_TOP
              RETURN_VALUE
```

Python uses short-circuiting - once it determines `1 < 2`, it evaluates `2 < 3`, unlike C which would evaluate `(1 < 2) < 3`.

---

## Integer Optimization

Python optimizes integers by preallocating integers in the range `-5` to `256`. Every time we need a number in this range, Python returns the preallocated object instead of creating a new instance.

We can verify this using the `id` function:

```python
>>> x, y = 36, 36
>>> id(x) == id(y)
True

>>> x, y = 257, 257
>>> id(x) == id(y)
False
```

The CPython implementation:

```c
static PyObject *
get_small_int(sdigit ival)
{
    PyObject *v;
    assert(-NSMALLNEGINTS <= ival && ival < NSMALLPOSINTS);  // NSMALLNEGINTS = 5, NSMALLPOSINTS = 257
    v = (PyObject *)&small_ints[ival + NSMALLNEGINTS];
    Py_INCREF(v);
    return v;  // return the preallocated integer instance
}
```

### Peephole optimizations

CPython also makes optimizations called "peephole optimizations," which can lead to some surprising behavior:

```python
>>> x = 1000
>>> y = 1000
>>> x is y
False  # In REPL

# But in a file this would return True
```

CPython preloads certain objects in memory:

1. Integer numbers between `-5` and `256`
2. Strings that contain only ASCII letters, digits, and underscores that are less than 20 characters long

```python
>>> s1 = "realpython"
>>> s2 = "realpython"
>>> s1 is s2
True

>>> s1 = "Real Python!"  # Contains non-alphanumeric characters
>>> s2 = "Real Python!"
>>> s1 is s2
False
```

---

## How Python's id() Works

The `id()` function returns the memory address of an object. It's defined in `bltinmodule.c`:

```c
static PyObject *
builtin_id(PyModuleDef *self, PyObject *v)
{
    PyObject *id = PyLong_FromVoidPtr(v);  // stores argument as a memory location in id

    if (id && PySys_Audit("builtins.id", "O", id) < 0) {
        Py_DECREF(id);
        return NULL;
    }

    return id;
}
```

The `PyLong_FromVoidPtr(v)` function converts a pointer to a Python long integer:

```c
PyLong_FromVoidPtr(void *p)
{
    return PyLong_FromUnsignedLong((unsigned long)(uintptr_t)p);
}
```

### The 'is' operator

The `is` operator in Python checks if two objects point to the same memory location:

```python
>>> a = 10
>>> b = 10
>>> a is b
True
>>> id(a)
4343226816
>>> id(b)
4343226816
```

In bytecode, the `is` operation is represented by the `IS_OP` instruction:

```python
>>> import dis
>>> dis.dis("a is b")
  0           RESUME                   0

  1           LOAD_NAME                0 (a)
              LOAD_NAME                1 (b)
              IS_OP                    0
              RETURN_VALUE
```

The implementation in `ceval.c`:

```c
case TARGET(IS_OP): {
    PyObject *right = POP();
    PyObject *left = TOP();

    // Check if two pointers are the same
    int res = Py_Is(left, right) ^ oparg;

    // Set the result on top of stack
    PyObject *b = res ? Py_True : Py_False;
    Py_INCREF(b);
    SET_TOP(b);
    Py_DECREF(left);
    Py_DECREF(right);
    DISPATCH();
}
```

The `oparg` value handles both `is` and `is not`:

```python
>>> dis.dis("a is b")
  0           RESUME                   0

  1           LOAD_NAME                0 (a)
              LOAD_NAME                1 (b)
              IS_OP                    0
              RETURN_VALUE
>>> dis.dis("a is not b")
  0           RESUME                   0

  1           LOAD_NAME                0 (a)
              LOAD_NAME                1 (b)
              IS_OP                    1
              RETURN_VALUE
```

---

## Adding a New Statement to Python

The Python main function is defined differently depending on the operating system:

```c
/* Minimal main program -- everything is loaded from the library */

#include "Python.h"

#ifdef MS_WINDOWS
int
wmain(int argc, wchar_t **argv)
{
    return Py_Main(argc, argv);
}
#else
int
main(int argc, char **argv)
{
    return Py_BytesMain(argc, argv);
}
#endif
```

Let's add a new statement called `nuke` that immediately kills the runtime with exit code 45:

```c
    | 'break' { _PyAST_Break(EXTRA) }
    | 'continue' { _PyAST_Continue(EXTRA) }
    | 'nuke' { _PyAST_nuke(EXTRA) }
// in python.gram

// in compile.c

    case Break_kind:
        return compiler_break(c);
    case Continue_kind:
        return compiler_continue(c);
    case Nuke_kind:
        return compiler_nuke(c);

static int
compiler_nuke(struct compiler *c)
{
    exit(45);  // implementation
}
```

After updating the grammar file with `make regen-pegen` and running `make`, we can use our new statement:

```
>>> nuke
[Program exits with code 45]
```

---

## Function Overloading in Python

Python doesn't natively support function overloading like C/C++:

```c
// C supports function overloading
int area(int len, int breadth) { return len * breadth; }
float area(int radius) { return 3.14 * radius * radius; }

// area(3,4) calls the first function, area(3) calls the second
```

In Python, defining a function with the same name overwrites the previous definition:

```python
def area(length, breadth): return length * breadth
locals()
# {'area': <function area at 0x104d1b420>}

def area(radius):
    return radius * radius * 3.14
locals()
# {'area': <function area at 0x104d1b2e0>}

print(area(4))  # 50.24
print(area(3,4))  # TypeError: area() takes 1 positional argument but 2 were given
```

### Implementing function overloading

We can simulate function overloading using decorators:

```python
from inspect import getfullargspec
from functools import wraps

class OverloadRegistry:
    """ Singleton class to hold overloaded functions """
    _instance = None  # private
    def __init__(self) -> None:
        if OverloadRegistry._instance is not None: raise Exception("Use get_instance() to get singleton instance")
        self.registry = {}
        OverloadRegistry._instance = self

    @classmethod
    def get_instance(cls):
        if cls._instance is None: cls._instance = OverloadRegistry()
        return cls._instance

    def _make_key(self, fn, args=None):
        if args is None: args = getfullargspec(fn).args
        return (fn.__module__, fn.__name__, len(args))  # key = {module, name, number of arguments}

    def register(self, fn):
        key = self._make_key(fn)
        self.registry[key] = fn  # attach this key to function

        @wraps(fn)
        def wrapper(*args, **kwargs):
            """ The @wraps decorator preserves metadata of the original function """
            match_key = (fn.__module__, fn.__name__, len(args))
            target_fn = self.registry.get(match_key)
            if not target_fn: raise TypeError("No matching function of this type")
            return target_fn(*args, **kwargs)
        return wrapper

def overload(fn):
    return OverloadRegistry.get_instance().register(fn)

@overload
def area(l, b): return l * b

@overload
def area(r): return r * r * 3.14

print(area(5,6))  # 30
print(area(3))    # 28.26
```

Python 3.4+ provides `functools.singledispatch` for function overloading based on argument types:

```python
from functools import singledispatch

@singledispatch
def area(shape):
    raise TypeError("Unsupported type")

@area.register
def _(dimensions: tuple):
    l, b = dimensions
    return l * b

@area.register
def _(radius: int):
    return 3.14 * radius * radius

print(area((5,6)))  # 30
print(area(3))      # 28.26
```

Python 3.8+ includes `singledispatchmethod` for class methods:

```python
from functools import singledispatchmethod
class AreaCalc:
    @singledispatchmethod
    def area(self, shape):
        raise TypeError("Unsupported Type")

    @area.register
    def _(self, dimensions: tuple):
        l, b = dimensions
        return l * b

    @area.register
    def _(self, radius: int):
        return 3.14 * radius * radius

calc = AreaCalc()
print(calc.area((5,6)))  # 30
print(calc.area(3))      # 28.26
```

---

## Parser and Tokenization

Python's parser uses Deterministic Finite Automata (DFA) to process tokens. We can see this at work:

```
$ ./python.exe -d test_tokens.py

Token NAME/'def' ... It's a keyword
 DFA 'file_input', state 0: Push 'stmt'
 DFA 'stmt', state 0: Push 'compound_stmt'
 DFA 'compound_stmt', state 0: Push 'funcdef'
 DFA 'funcdef', state 0: Shift.
Token NAME/'my_function' ... It's a token we know
 DFA 'funcdef', state 1: Shift.
Token LPAR/'(' ... It's a token we know
...
```

DFA visualisation:
![DFA](https://i.ibb.co/HfnpJkLK/DFAPython.png)

---

## Visualizing Abstract Syntax Trees

The CPython interpreter converts input code into an Abstract Syntax Tree (AST). We can visualize this using the `instaviz` package:

```python
import instaviz

def main():
    a = 2 * 2 * 2 * 2
    b = 1 + 5
    c = [1, 4, 6]
    for i in c:
        print(i)
    else:
        print(a)
    return c

instaviz.show(main)
```

You can see the AST here which shows all loops/conditional statements:
![AST](https://i.ibb.co/QFwZp5CG/Python-AST.png)

The compiler then converts this AST into something the CPU can understand in two parts:

1. Creating a control-flow-graph representing the execution sequence
2. Converting CFG nodes into smaller executable statements (bytecode)

---

## Pointers in Python

While Python doesn't expose pointers to users, they're fundamental to CPython's implementation. For more information, see [this article on pointers in Python](https://realpython.com/pointers-in-python/).

---

## The Print Function Internals

The implementation of Python's `print()` function in CPython:

```c
static PyObject *
builtin_print(PyObject *self, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
{
    // If no file specified, use stdout
    if (file == NULL || file == Py_None) {
        file = _PySys_GetObjectId(&PyId_stdout);
        // ...
    }

    // Print each argument with separator
    for (i = 0; i < nargs; i++) {
        if (i > 0) {
            if (sep == NULL)
                err = PyFile_WriteString(" ", file);
            else
                err = PyFile_WriteObject(sep, file, Py_PRINT_RAW);
            if (err)
                return NULL;
        }
        err = PyFile_WriteObject(args[i], file, Py_PRINT_RAW);
        if (err)
            return NULL;
    }

    // Print end character (default: newline)
    if (end == NULL)
        err = PyFile_WriteString("\n", file);
    else
        err = PyFile_WriteObject(end, file, Py_PRINT_RAW);

    Py_RETURN_NONE;
}
```

When you call `print("hello world!")`:

1. The string `"hello world"` is converted to a `PyUnicodeObject`
2. `builtin_print()` executes with 1 argument
3. The `file` variable is set to `stdout`
4. The argument is sent to `file`
5. A line break (`\n`) is sent to `file`

---

## Python is slow as hell

Comparing OOP in Python and C++ by creating Tree class for both and measuring time it takes to run:

```python
"""
BST Structure
     5
    / \
   3   7
  /     \
 1       9
"""

import time
import random
class Node:
    def __init__(self, data) -> None:
        self.left = None
        self.right = None
        self.data = data

class BST:
    def __init__(self) -> None:
        self.root = None

    def insert(self, data):
        if self.root is None: self.root = Node(data)
        else:
            self._insert(data, self.root)

    def _insert(self, data, currNode):
        if data < currNode.data:
            # left tree
            if currNode.left is None: currNode.left = Node(data)
            else:
                self._insert(data, currNode.left)
        elif data > currNode.data:
            if currNode.right is None: currNode.right = Node(data)
            else:
                self._insert(data, currNode.right)
        else:
            print("Value already in tree")

def inorder(node): # L N R
    if node:
        inorder(node.left)
        print(node.data)
        inorder(node.right)



def run_python_benchmark():
    nums = random.sample(range(1, 100000), 10000)  # 10,000 unique numbers
    tree = BST()
    start = time.time()
    for num in nums:
        tree.insert(num)
    end = time.time()
    print(f"Python BST insert time: {end - start:.6f} seconds")

run_python_benchmark()
```

```C++
#include <iostream>
#include <chrono>
#include <vector>
#include <algorithm>
#include <random>

using namespace std;
using namespace std::chrono;

class Node
{
public:
    int data;
    Node *left;
    Node *right;

    Node(int val)
    {
        data = val;
        left = right = nullptr;
    }
};

class BST
{
public:
    Node *root;

    BST()
    {
        root = nullptr;
    }

    void insert(int data)
    {
        if (!root)
            root = new Node(data);
        else
            insertHelper(data, root);
    }

private:
    void insertHelper(int data, Node *currNode)
    {
        if (data < currNode->data)
        {
            if (!currNode->left)
                currNode->left = new Node(data);
            else
                insertHelper(data, currNode->left);
        }
        else if (data > currNode->data)
        {
            if (!currNode->right)
                currNode->right = new Node(data);
            else
                insertHelper(data, currNode->right);
        }
    }
};

int main()
{
    vector<int> nums(10000);
    iota(nums.begin(), nums.end(), 1);
    shuffle(nums.begin(), nums.end(), mt19937(random_device{}()));

    BST tree;

    auto start = high_resolution_clock::now();
    for (int n : nums)
        tree.insert(n);
    auto end = high_resolution_clock::now();

    duration<double> elapsed = end - start;
    cout << "C++ BST insert time: " << elapsed.count() << " seconds" << endl;
    return 0;
}
```

### Performance Comparison:

| Language | Average Time (per run) |
| -------- | ---------------------- |
| Python   | **14.52 milliseconds** |
| C++      | **2.22 milliseconds**  |

**C++ is approximately 7x faster in this case.**

---

## Python Execution Process

Why is Python considered slow? As it compiles and interprets code at runtime, unlike languages like C/C++ that compile directly to machine code.

Most modern language interpreters are written in C, and Python's most popular implementation (CPython) is no exception.

The Python execution process:

1. Python compiler reads source code
2. Code is saved as a `.py` file
3. Compilation stage: source code is converted to bytecode and a `.pyc` file is generated
4. Python Virtual Machine (PVM) interprets the bytecode
5. PVM converts bytecode to machine code (binary)
6. CPU executes the machine code for the final output

Reading about this for the past 3 days has made me appreciate C so much. Beautiful how a non-OOP language can be used to write a language like Python.

---

## References

- [CPython Guide](https://realpython.com/cpython-source-code-guide/)
